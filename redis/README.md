# Redis应用场景
Redis是一个key-value存储系统，现在在各种系统中的使用越来越多，大部分情况下是因为其高性能的特性，被当做缓存使用。除了可以做缓存外,Redis还可以在其它什么场景使用哪？


## Redis特性
一个产品的使用场景需要根据产品特性,先列举一下Redis的特点：

* 读写性能优异
* 持久化
* 数据类型丰富
* 单线程
* 数据自动过期
* 发布/订阅
* 分布式


## Redis具体使用场景
我们通过几个场景,从不同维度分析Redis的应用。


### 缓存
缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。 作为缓存使用时，一般有两种方式保存数据：

* 先读缓存: 当需要获取数据时,首先从Redis获取数据。如果没有数据,读取数据库,将数据拉入Redis(类似CDN访问方式)。
* 写时缓存: 当数据插入数据库时,同时写入Redis一份。

#### 先读缓存
实现简单,但是有两个点需要注意:

* 避免缓存击穿。(数据库没有需要命中的数据,导致Redis一直没有Cache,而一直命中数据库。)
* 数据实时性相对会差一些。

#### 写时缓存
数据实时性强，但是开发时不便于统一处理。当然，两种方式根据实际情况来适用。

* 先读缓存适用于数据实时性要求不是很高的场景。
* 写时缓存适用于字典、数据量不是很大的数据存储。


### 按数据类型维度划分
虽然Redis不像关系数据库那么复杂的数据结构。但是,也能适合很多场景,比一般的缓存数据结构要多.了解每种数据结构适合的业务场景,不仅有利于提升开发效率,也能有效利用Redis的性能。

####  Redis 字符串- K/V存储
使用Redis字符串类型适合最简单的k/v存储,类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。

####  Redis Hash
使用Redis hash,一般key为ID或者唯一标示,value存储具体详情信息。如,商品详情,个人信息详情,新闻详情等。

#### Redis list
list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。

#### Redis set
可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。

#### Redis Sorted Set
是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。


### 单线程-分布式锁
谈到Redis和Memcached的区别，大家更多的是谈到数据结构和持久化这两个特性，其实还有一个比较大的区别就是：

* Redis是单线程,多路复用方式提高处理效率。
* Memcached 是多线程的，通过CPU线程切换来提高处理效率。

Redis单线程的这个特性，其实也是很重要的应用场景，最常用的就是分布式锁。

高并发的系统，都是用多服务器部署，每个技术框架针对数据锁都有很好的处理方式，如Go的mutex,java 的synchronized,都能通过锁住某个对象来应对线程导致的数据污染问题。但是毕竟，只能控制本服务器的线程，分布式部署以后数据污染问题，就比较难处理了。Redis的单线程这个特性，就非常符合这个需求，伪代码如下：

```
// 产生锁
while lock != 1
	// 过期时间为了避免死锁
	now = int(time.time())
	lock_timeout = now + LOCK_TIMEOUT + 1
	lock = redis_client.setnx(lock_key, lock_timeout)
	
// 真正要处理的业务
doing()

// 释放锁
now = int(time.time())
if now < lock_timeout:
	redis_client.delete(lock_key)
```

以上是一个只说明流程的伪代码，其实整体的逻辑是很简单的，只要考虑到死锁时的情况，就比较好处理了。Redis作为分布式锁，因为其性能的优势，不会成为瓶颈，一般会产生瓶颈的是真正的业务处理内容，还是尽量缩小锁的范围来确保系统性能。


### 设置数据过期时间
Redis针对数据都可以设置过期时间，这个特点也是大家应用比较多的，过期的数据清理无需使用方去关注，所以开发效率也比较高，当然，性能也比较高。最常见的就是：短信验证码、具有时间性的商品展示等。无需像数据库还要去查时间进行对比。


### 分布式和持久化(应对海量数据和高并发)

#### 分布式
Redis初期的版本官方只是支持单机或者简单的主从，大多应用则都是自己去开发集群的中间件，但是随着应用越来越广泛，用户关于分布式的呼声越来越高，所以Redis 3.0版本时候官方加入了分布式的支持，主要是两个方面：

* Redis服务器主从热备,确保系统稳定性。
* Redis分片应对海量数据和高并发。

#### 持久化
Redis虽然是一个内存缓存，数据存在内存，但是Redis支持多种方式将数据持久化，写入硬盘。所以，Redis数据的稳定性也是非常有保障的，结合Redis的集群方案，有的系统已经将Redis当做一种NoSql数据存储来适用。


### 应用场景案例
秒杀是现在互联网系统中常见的营销模式，作为开发者，其实最不愿意这样的活动，因为非技术人员无法理解到其中的技术难度，导致在资源协调上总是有些偏差。秒杀其实经常会出现的问题包括：

* 并发太高导致程序阻塞。
* 库存无法有效控制，出现超卖的情况。

解决这些问题基本就两个方案：

* 数据尽量缓存,阻断用户和数据库的直接交互。
* 通过锁来控制避免超卖现象。

如果现在做一个秒杀，那么，Redis应该如何结合进行使用?

* 提前预热数据，放入Redis
* 商品列表放入Redis List
* 商品的详情数据 Redis hash保存，设置过期时间
* 商品的库存数据Redis sorted set保存
* 用户的地址信息Redis set保存
* 订单产生扣库存通过Redis制造分布式锁，库存同步扣除
* 订单产生后发货的数据，产生Redis list，通过消息队列处理
* 秒杀结束后，再把Redis数据和数据库进行同步

以上是一个简单的秒杀系统和Redis结合的方案。当然,实际可能还会引入http缓存,或者将消息对接用MQ替代等方案,也会出现业务遗漏。